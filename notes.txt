#################### 1 ####################
Start with Django with platzi course
#################### 1 ####################

1. we need to create a development environment

for windows:
    1.1. py -m venv ven
    1.2. .\Scripts\activate

for linux:
    1.1. python3 -m venv venv
    1.2. source venv/bin/activate

2. Install Django framework:
    2. pip install django

3. Create a project with django:
    3. django-admin startproject project_name

4. Inicialize git and use "touch" to avoid push .venv folder to the github repository
    4.1. git init
    4.2. touch .gitignore

5. Run server (we need to be into the app folder):
    5. py manage.py runserver

6. Project and apps in Django:
    Django names project like a container of multiples apps, one app is just functionality of our project:
    Example:
    Instagram = Project
    Feed = app
    Stories = app
    Messages = app

7. To create a new app into a our project, we need to type the next code in our terminal
    7.1 Into a project folder: py manage.py startapp name_of_the_app
    7.2 Don't forget we need to include this new app into the settings.py file (project folder), in the section "INSTALLED_APPS", it must be aim to apps.py of each app folder.

8. For each app, we need to define its urls.py file wherein it includes throghout path() function. 
    Also, we have to include the path of our new urls.py file for each app into our main urls.py 
    file (main directory)

9. ORM = Object Relational Mapping. We use this method to transform tables of our databases to OOP structure in Django. So, we create models of our tables.

    9.1 We create into "models.py" file into our app, the classes related to each table. Don't forget to see how we specify the data-types for each attribute (attribute = fields of our table). Peed how we relate primary keys with foreign key. Also, check how we don't create a attribute with "id" field, because Django establishes that automatically.

    9.2 When we already create the classes, we need to execute the next code in the terminal:
        9.2.1 py manage.py makemigrations app_name: This code create a new folder into the app folder, named "migrations" and file "0001_initial.py". This code execute the ORM method.

        9.2.2 py manage.py migrate: this code apply and execute the file named "0001_initial.py" wherein we can see the model structure of our classes or tables. Now, this file is executed in the database choiced (this case, sqlite3).
    
    Note: for each change in our classes, we need to execute these commands again.

10. Django allows us to use its interactive console, in order to interact with python console.
    10.1 The command is: py manage.py shell
    
    10.2 Once we are into the interactive console, we can import our app classes and interact with our databases.
    ** For example, we can see all attributes (list of the objects or records) with the function .all()
        ex. ClassModel.objects.all()
    ** Another example could be when we have to create a new record into our model:
        ex. record_1 = ClassModel(attribute_1 = "attribute_1", attribute_2 = "attribute_2").save() or
            ClassModel.objects.create(attribute_1 = "attribute_1", attribute_2 = "attribute_2") 
    
    ** Likewise, we can use the .get() method to filter for primary key, the filter always must return 1 record:
        ex. ClassModel.objects.get(pk=1)
    ** Conversaly, we able to filter with some special features using "__" before "=" signal, for example:
        ex. ClassModel.objects.get(pub_date__year=timezone.now().year)
    If the filter doesn't return outcomes, exist a warning to indicate the record doesn't exist in the current model, we can use this warning when we want to control the flow of our program managing the exceptions.

    ** Furthermore, we can use .filter() function to get a iterable object with the outcomes:
        ex. ClassModel.objects.filter(pub_date__year=timezone.now().year)
            ClassModel.objects.filter(question_text__startswith="Â¿cual")
        ** Some functions to keep in mint:
        __gt = Mayor que
        __gte = Mayor o igual que
        __lt = Menor que
        __lte = Menos o igual que
        __startswith = Empieza con
        __endswith = Termina con
        __contains: Contiene

    ** To finish, we can use the foreign key and primary key for interact with data. The relation between two tables is manage for the function "className"_set.all(). When we create our ForeignKey into the class model, we should use the parameter "relate_name=" to especify the name of the relacion, example:

        ClassModel.className_set.all()
        it could be:
        ClassModel.nameSetWithRelateName.all()

        ex:
        >>> q_1.question_choices.create(choice_text="azure data factory - avanzado", votes=0)
        <Choice: azure data factory - avanzado>
        >>> q_1.question_choices.create(choice_text="sql - avanzado", votes=0)
        <Choice: sql - avanzado>
        >>> q_1.question_choices.all()
        <QuerySet [<Choice: Python3 - basico>, <Choice: Python3 - intermedio>, <Choice: Python3 - avanzado>, <Choice: azure data factory - avanzado>, <Choice: sql - avanzado>]>
       
        ex2:
        >>> Choice.objects.filter(question__pub_date__year=timezone.now().year)
        <QuerySet [<Choice: Python3 - basico>, <Choice: Python3 - intermedio>, <Choice: Python3 - avanzado>, <Choice: azure data factory - avanzado>, <Choice: sql - avanzado>]>

11. Django allows us to create a super admin user, this one can access to a user interface in order to watch our model.
Firstly, we can create a super user using the command:
    py manage.py createsuperuser
    
    ** Here, we have to type our name, email and password. This credencial is critical to lost.

Once we create our super user, we need to specify in the file "admin.py" the module of our app in order to show it in the admin user interface of django.


12. Architecture of Django web app: MTV
    M = Model (backend)
    T = Template (frontend)
    V = Views (backend)

    Views allows us to define and program the logic of each web pages. When our view are ready, we use Templates to create the frontend of our app.

13. Views in Django. We can create views in functions python or classes python. Each view define the each page of our webapp. Always, the main parameter for our views includes "request", after that, we can add another parameter. The response of the return function could be a "HttpReponse".
After we define our views, we need to aggregate our views into the file urls.py of the app file.

14. Templates in Django. The front of our app is manage with templates by Django. We have to install a nice plugging called "Django" in VSC to facility the type code. Furthermore, we have to aggregate a line of code in the settings.json file of the VSC in order to be able to write HTML code and Django backend code. Here, this one:
        "emmet.includeLanguages": {
            "django-html": "html"
        }

    Into the template, we can programate the interactions between views and templates. We must keep in mint that functions in the view.py is a view of our app, so, into each view, we can render the template using the render() function. This one admit 3 parameters, the first one is the "request", the second one is the path of our template and the third one is the python diccionary with the variables that we need to use in our templates.

15. All of the views must be a right response or error response. To manage the error 404 when the database consult is not effective, we can use the shortcut "get_object_or_404" from the django.shortcuts library.

    ex. question = get_object_or_404(Model, pk=some_number)
    If the pk is not found, Django automatically raise a 404 http error.


16. If we need to change the name of the path in our url, we need to relate the url.py with our templates.
The best way to do it, is to use the function "%% url %% and modify the url.py with a static variable and to be careful with the label "name" of each path.
Example:
    app_name="my_app_name"

    #example: polls/1
    path('<int:id_question>/detail', views.number_question, name='number_question')

    our template will use app_name:name

17. Forms: The basic concepts.
    We use html forms to create the forms structure. We have to understand we create the view with variables that probably contains a Model object. When we're rendering the view althrough templates, we use those variables in order to call the values of the model.
    In addition, exist a excellent function in django to look out our forms with post method:
        {% csrf_token %}
    We shall use this line always.

18. The flow of Django views of our webapp is so interesting because we can render various views accoring to the need. Exists a new concepts to keep in mint:
        HttpResponseRedirect(reverse('app_name:label_name_url', args=(parameter_of_url,)))
    If something into the flow of the view happens, we can redirect to other template.
    
    Another important concept is how can we get the values from the forms?
    Once the user execute the botton "send", the information travel through the request.POST[] function. So, we can access to the list of the python with the key value.
        ex. request.POST['key_of_list']  


